{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Epic: Migrate AI integration to Gemini 2.5 Pro",
        "description": "Replace OpenAI with @google/genai, use model `gemini-2.5-pro`, add streaming + JSON mode, secure key handling in Electron main via IPC, update tests/docs.",
        "details": "Scope: main-process client, streaming to renderer, JSON mode for summaries, settings UI for key, repo-wide replacement, security posture per Electron docs.",
        "testStrategy": "Unit tests for client wrapper, IPC handlers, and JSON parsing; integration smoke for streaming UI.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Spike: Set up @google/genai client and streaming in Electron main",
        "description": "Install @google/genai, initialize GoogleGenAI with GEMINI_API_KEY, implement generateContentStream wrapper and log chunks.",
        "details": "Create a main-process module `src/main/ai/gemini.ts` exporting `stream(prompt)` and `json(prompt)` using model `gemini-2.5-pro`. Wire minimal error handling.",
        "testStrategy": "Unit: mock SDK; assert streaming iteration and error handling.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "IPC bridge: expose Gemini generate + streaming to renderer",
        "description": "Add ipcMain handler and event channel; preload contextBridge exposes invoke and listener; validate sender; no key leakage.",
        "details": "Add channels: `gemini:generate` (invoke) and `gemini:stream` (event). Update preload to expose minimal API. Update window creation to set security flags.",
        "testStrategy": "Unit: mock ipcMain handlers; integration: preload exposure shape.",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Renderer: integrate streaming UI and buffering",
        "description": "Adapt chat/editor to consume stream chunks, buffer safely, finalize completion, and handle errors/cancellations.",
        "details": "Add a React hook/useGeminiStream for subscription; ensure UI state transitions match existing behavior; debounce renders.",
        "testStrategy": "Integration: mount component and simulate chunked updates; ensure final text matches.",
        "status": "pending",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "JSON mode: structured summaries and parsing",
        "description": "Add generationConfig.responseMimeType='application/json' for summary endpoints; robust JSON parse with fallback and user feedback.",
        "details": "Create helper `generateJson(prompt)` with schema-in-prompt; surface parse errors with toasts; add typing to parsed objects.",
        "testStrategy": "Unit: valid/invalid JSON responses; UI: shows error toast when invalid.",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Settings: Gemini API key input + validation",
        "description": "Add UI to store/validate GEMINI_API_KEY (main process storage) and block AI actions when missing/invalid.",
        "details": "Reword settings from OpenAI to Gemini; add key test ping; never expose key to renderer logs; update README copy.",
        "testStrategy": "Unit: validation logic; UI: disables actions without key; e2e: happy path store + use.",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Repo-wide replacement: remove OpenAI, wire Gemini services",
        "description": "Remove `openai` package and usages; replace with Gemini service calls in contexts and handlers; update typings.",
        "details": "Search and replace: chat/completions → generateContent/stream; update prompt builders; revisit rate-limit/backoff handlers.",
        "testStrategy": "Run full test suite; smoke run on all AI features; ensure no OpenAI imports remain.",
        "status": "pending",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Security & CSP: enforce Electron best practices",
        "description": "Verify contextIsolation, nodeIntegration, preload exposure, and add/adjust CSP. Validate IPC sender origins; sanitize inputs.",
        "details": "Audit BrowserWindow creation, preload API surface, and enable strict CSP for renderer assets.",
        "testStrategy": "Manual audit checklist + unit tests for preload API shape; verify no node APIs in renderer.",
        "status": "pending",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Tests and CI adjustments",
        "description": "Update unit/integration tests for Gemini workflows; ensure CI scripts keep lint, type-check, packaging, and tests green.",
        "details": "Add mocks for @google/genai; update jest setup if needed; ensure streaming tests are deterministic.",
        "testStrategy": "Jest unit tests for wrappers; integration tests for streaming buffer and JSON parsing.",
        "status": "pending",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Docs & release notes",
        "description": "Update README, AGENTS.md, and in-app copy to reference Gemini; add migration notes and release highlights.",
        "details": "Document settings changes, model defaults, and limitations; include references to Google docs.",
        "testStrategy": "Docs review checklist; ensure commands and paths resolve.",
        "status": "pending",
        "dependencies": [
          "7",
          "8",
          "9"
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-26T16:01:27.799Z",
      "description": "Default tasks context",
      "updated": "2025-08-26T16:02:38.062Z"
    }
  },
  "research": {
    "tasks": [
      {
        "id": 1,
        "title": "Epic: Migrate AI integration to Gemini 2.5 Pro",
        "description": "Replace OpenAI with @google/genai, use model `gemini-2.5-pro`, add streaming + JSON mode, secure key handling in Electron main via IPC, update tests/docs.",
        "details": "Scope: main-process client, streaming to renderer, JSON mode for summaries, settings UI for key, repo-wide replacement, security posture per Electron docs.",
        "testStrategy": "Unit tests for client wrapper, IPC handlers, and JSON parsing; integration smoke for streaming UI.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Spike: Set up @google/genai client and streaming in Electron main",
        "description": "Install @google/genai, initialize GoogleGenAI with GEMINI_API_KEY, implement generateContentStream wrapper and log chunks.",
        "details": "Create a main-process module `src/main/ai/gemini.ts` exporting `stream(prompt)` and `json(prompt)` using model `gemini-2.5-pro`. Wire minimal error handling.",
        "testStrategy": "Unit: mock SDK; assert streaming iteration and error handling.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install @google/genai and scaffold main client",
            "description": "Add dependency, create `src/main/ai/gemini.ts` with model init (`gemini-2.5-pro`).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "Implement generateContentStream wrapper",
            "description": "Expose `stream(prompt)` that yields text chunks; add error handling and abort support.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "Implement JSON generation helper",
            "description": "Expose `json(prompt)` using `responseMimeType: 'application/json'` and safe parsing.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "Add basic unit tests with SDK mocks",
            "description": "Mock @google/genai and test stream/json helpers for happy/error paths.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 5,
            "title": "Install @google/genai dependency",
            "description": "Add the @google/genai package to the project's dependencies using the project's package manager (npm or yarn).",
            "dependencies": [],
            "details": "Run `npm install @google/genai` or `yarn add @google/genai` and confirm its addition to the `package.json` file. Verify that the project's dependencies can be installed successfully afterward.",
            "status": "done",
            "testStrategy": "Confirm the package is listed in `package.json` and the lock file. Run `npm install` or `yarn install` to ensure no dependency conflicts arise."
          },
          {
            "id": 6,
            "title": "Create gemini.ts module and initialize client",
            "description": "Create the file `src/main/ai/gemini.ts` and implement the initialization logic for the GoogleGenAI client.",
            "dependencies": [],
            "details": "In the new module, import `GoogleGenerativeAI`. Instantiate the client using `new GoogleGenerativeAI(process.env.GEMINI_API_KEY)`. For the spike, the key can be loaded directly from environment variables.\n<info added on 2025-08-26T16:23:21.739Z>\nThe client is initialized with `gemini-2.5-pro` model. Basic structure for `stream` and `json` functions is in place.\n</info added on 2025-08-26T16:23:21.739Z>",
            "status": "done",
            "testStrategy": "Unit test: Mock `process.env.GEMINI_API_KEY` and assert that the `GoogleGenerativeAI` constructor is called with the expected key."
          },
          {
            "id": 7,
            "title": "Implement `stream(prompt)` function",
            "description": "Implement and export an async generator function `stream(prompt)` that calls the Gemini API for streaming responses and logs the chunks.",
            "dependencies": [],
            "details": "Within `gemini.ts`, create the `stream` function. It should get the `gemini-2.5-pro` model from the initialized client, call `generateContentStream({ prompt })`, and iterate through the resulting stream. Log the text from each chunk to the main process console.\n<info added on 2025-08-26T16:24:17.364Z>\nAdditionally, ensure it is an async generator function that yields the text content from each chunk and includes proper error handling with try/catch.\n</info added on 2025-08-26T16:24:17.364Z>",
            "status": "done",
            "testStrategy": "Unit test: Mock the `generateContentStream` method to return a simulated async iterable. Assert that the function iterates correctly and that the content of each chunk is processed as expected."
          },
          {
            "id": 8,
            "title": "Implement `json(prompt)` function",
            "description": "Implement and export an async function `json(prompt)` that calls the Gemini API to get a structured JSON response.",
            "dependencies": [],
            "details": "Within `gemini.ts`, create the `json` function. It should use the `gemini-2.5-pro` model and the `generateContent` method. The implementation should request a JSON response and parse the text output into a JavaScript object before returning it.\n<info added on 2025-08-26T16:25:19.669Z>\n, automatically adds JSON format instruction to prompts if not present, logs the response, and includes proper error handling with try/catch.\n</info added on 2025-08-26T16:25:19.669Z>",
            "status": "done",
            "testStrategy": "Unit test: Mock the `generateContent` method to return a mock response containing a valid JSON string. Assert that the function returns a correctly parsed JavaScript object."
          },
          {
            "id": 9,
            "title": "Add minimal error handling and finalize exports",
            "description": "Wrap the API calls in both the `stream` and `json` functions with try/catch blocks to handle and log potential API or network errors.",
            "dependencies": [],
            "details": "In `gemini.ts`, add `try...catch` blocks around the `generateContentStream` and `generateContent` calls. In the catch block, log a descriptive error message to the console. Ensure both `stream` and `json` functions are properly exported from the module's public interface.\n<info added on 2025-08-26T16:26:09.023Z>\nErrors are re-thrown appropriately from the catch blocks. In addition to `stream` and `json`, `genAI` and `model` functions are also exported from the module's public interface.\n</info added on 2025-08-26T16:26:09.023Z>",
            "status": "done",
            "testStrategy": "Unit test: Mock the SDK methods to throw a specific error. Assert that the error is caught, logged, and that the function gracefully terminates or throws a custom error."
          }
        ]
      },
      {
        "id": 3,
        "title": "IPC bridge: expose Gemini generate + streaming to renderer",
        "description": "Add ipcMain handler and event channel; preload contextBridge exposes invoke and listener; validate sender; no key leakage.",
        "details": "Add channels: `gemini:generate` (invoke) and `gemini:stream` (event). Update preload to expose minimal API. Update window creation to set security flags.",
        "testStrategy": "Unit: mock ipcMain handlers; integration: preload exposure shape.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "ipcMain handler for non-stream JSON",
            "description": "`ipcMain.handle('gemini:generate')` returns JSON or text; validate input and sanitize.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "Streaming channel and preload bridge",
            "description": "Send chunks via `webContents.send('gemini:stream', data)`; preload exposes `onGeminiResponse` and `invokeGemini`.",
            "details": "<info added on 2025-08-26T16:29:16.937Z>\nImplemented streaming channel functionality: Added 'gemini:stream' IPC handler that streams chunks via webContents.send() with unique stream IDs. Updated preload.ts to expose onGeminiResponse() listener and invokeGemini()/startStream() methods. Includes proper stream lifecycle management (start/chunk/end/error events) and cleanup functions.\n</info added on 2025-08-26T16:29:16.937Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "Type declarations and sender validation",
            "description": "Update `src/renderer/preload.d.ts`; validate sender frame URL is `file:` before serving requests.",
            "details": "<info added on 2025-08-26T16:30:55.209Z>\nSender validation added to Gemini IPC handlers, ensuring `file://` protocol for sender frame URL. TypeScript type definitions (`GeminiResponse`, `GeminiStreamResponse`, `GeminiStreamEvent`) created in `src/main/types/gemini.ts` and used to update handler return types for improved type safety. Preload type declarations are automatically included via `ElectronHandler`.\n</info added on 2025-08-26T16:30:55.209Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 4,
            "title": "Security: narrow preload API surface",
            "description": "Expose only functions needed; no raw ipcRenderer; add input schema validation.",
            "details": "<info added on 2025-08-26T16:32:39.643Z>\nAdded comprehensive input schema validation to all Gemini functions (prompt type/length checks, callback function validation). Added data structure validation for streaming responses before passing to callbacks.\n</info added on 2025-08-26T16:32:39.643Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Renderer: integrate streaming UI and buffering",
        "description": "Adapt chat/editor to consume stream chunks, buffer safely, finalize completion, and handle errors/cancellations.",
        "details": "Add a React hook/useGeminiStream for subscription; ensure UI state transitions match existing behavior; debounce renders.",
        "testStrategy": "Integration: mount component and simulate chunked updates; ensure final text matches.",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create useGeminiStream hook",
            "description": "Hook subscribes to `onGeminiResponse`, buffers chunks, exposes status and cancel.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "Integrate hook into chat/editor",
            "description": "Replace OpenAI streaming usage with Gemini; preserve UX and keyboard shortcuts.",
            "details": "<info added on 2025-08-26T16:37:46.906Z>\nCompleted AIContext.js integration:\n- Updated default pileAIProvider from 'openai' to 'gemini'\n- Updated default model to 'gemini-2.5-pro' \n- Modified setupAi() function to handle Gemini initialization (sets ai type to 'gemini')\n- Updated generateCompletion() to support Gemini streaming with proper event handling\n- Enhanced checkApiKeyValidity() for Gemini validation using invokeGemini test call\n- Preserved existing OpenAI and Ollama compatibility\n- All context values properly exposed to consumers\n</info added on 2025-08-26T16:37:46.906Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "Handle errors, cancel, and finalize state",
            "description": "Ensure UI shows errors, allows cancellation, and finalizes on stream end.",
            "details": "<info added on 2025-08-26T16:41:49.285Z>\nCompleted error handling, cancellation, and finalized state UI:\n\nChat Component Enhancements:\n- Added error state management with setError/error state\n- Added canCancel state for showing/hiding cancel button\n- Enhanced onSubmit with try/catch error handling and proper cleanup\n- Added onCancelAI function for cancelling AI requests\n- Added error message UI display with dismissible error banner\n- Enhanced onResetConversation to clear error state\n- Added conditional Cancel AI button in header (replaces Clear chat when streaming)\n\nEditor Component Enhancements:\n- Added canCancelAI state for tracking cancellation availability\n- Enhanced generateAiResponse with better error messages showing actual error details\n- Added cancelAiResponse function with proper cleanup and user feedback\n- Improved error notifications to show specific error messages instead of generic \"AI request failed\"\n- Added proper state management for cancellation throughout AI response lifecycle\n\nBoth components now properly handle Gemini streaming errors, provide cancellation capabilities, and show appropriate UI feedback for all states (streaming, error, completion, cancellation).\n</info added on 2025-08-26T16:41:49.285Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "JSON mode: structured summaries and parsing",
        "description": "Add generationConfig.responseMimeType='application/json' for summary endpoints; robust JSON parse with fallback and user feedback.",
        "details": "Create helper `generateJson(prompt)` with schema-in-prompt; surface parse errors with toasts; add typing to parsed objects.",
        "testStrategy": "Unit: valid/invalid JSON responses; UI: shows error toast when invalid.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define JSON prompt templates",
            "description": "Create strict, minimal JSON schemas and prompts for summaries and metadata.",
            "details": "<info added on 2025-08-26T16:46:33.505Z>\n- Created `SummaryResponse` and `MetadataResponse` interfaces for parsed JSON output.\n- Added `JSONTemplateResponse` union type for type safety of parsed responses.\n</info added on 2025-08-26T16:46:33.505Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Add parse utility with safe fallback",
            "description": "Gracefully handle invalid JSON; provide error messages and default values.",
            "details": "<info added on 2025-08-26T16:49:36.086Z>\nCompleted safe JSON parsing utility with comprehensive error handling:\n\nMain Parser Module (jsonParser.ts):\n- Created comprehensive JSONParseError enum with error types\n- Implemented ParseResult interface with success/error structure\n- Added validateSummaryResponse() and validateMetadataResponse() functions\n- Created cleanJsonString() to handle common JSON formatting issues (markdown blocks, boundaries)\n- Implemented parseSummaryResponse() and parseMetadataResponse() with length limits\n- Added safeParseJson() generic function with template-specific validation\n- Created DEFAULT_VALUES fallbacks for both template types\n\nRenderer Utilities (jsonHelper.js):\n- Added generateStructuredResponse() with error callback support\n- Created formatErrorMessage() for user-friendly error display\n- Implemented validateResponseCompleteness() for data quality checks\n- Added createErrorToast() for notification integration\n- Provided getDefaultResponse() fallback mechanism\n\nIPC Enhancement:\n- Enhanced GeminiResponse type with parseWarning field\n- Updated generate-json handler to detect fallback usage\n- Added warning detection for invalid responses\n\nExample Implementation:\n- Created JsonExample.jsx component demonstrating full error handling workflow\n- Shows toast notifications for errors and warnings\n- Provides complete reference implementation\n\nThe system now gracefully handles invalid JSON, provides user feedback, and continues functioning with fallback values.\n</info added on 2025-08-26T16:49:36.086Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Settings: Gemini API key input + validation",
        "description": "Add UI to store/validate GEMINI_API_KEY (main process storage) and block AI actions when missing/invalid.",
        "details": "Reword settings from OpenAI to Gemini; add key test ping; never expose key to renderer logs; update README copy.",
        "testStrategy": "Unit: validation logic; UI: disables actions without key; e2e: happy path store + use.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Settings UI updates and copy",
            "description": "Rename OpenAI references to Gemini; adjust help text and validation messages.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 2,
            "title": "Key storage and validation flow",
            "description": "Store key in main process; add a test request; block actions when invalid/missing.",
            "details": "<info added on 2025-08-26T17:54:01.121Z>\nCompleted key storage and validation flow implementation:\n\nKey Storage Enhancement:\n- Modified Gemini client to use stored API key from electron-settings instead of environment variables\n- Added initializeGemini() function to properly initialize client with stored key\n- Updated stream() and json() functions to ensure client is initialized before use\n- Added re-initialization when API key is updated via set-ai-key handler\n\nValidation Flow:\n- Existing checkApiKeyValidity() in AIContext already properly validates Gemini keys by making test API call\n- Key storage uses electron's safeStorage for encrypted storage in main process\n- Settings UI properly calls setKey() when saving changes\n- Delete key functionality properly removes stored credentials\n\nThe system now properly stores, validates, and uses Gemini API keys with secure main process storage and automatic client re-initialization when keys change.\n</info added on 2025-08-26T17:54:01.121Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Repo-wide replacement: remove OpenAI, wire Gemini services",
        "description": "Remove `openai` package and usages; replace with Gemini service calls in contexts and handlers; update typings.",
        "details": "Search and replace: chat/completions → generateContent/stream; update prompt builders; revisit rate-limit/backoff handlers.",
        "testStrategy": "Run full test suite; smoke run on all AI features; ensure no OpenAI imports remain.",
        "status": "done",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove OpenAI deps and imports",
            "description": "Uninstall openai, update package.json/locks; remove imports across codebase.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 2,
            "title": "Replace service/context calls with Gemini",
            "description": "Refactor usage to gemini service; adjust error and backoff logic.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          }
        ]
      },
      {
        "id": 8,
        "title": "Security & CSP: enforce Electron best practices",
        "description": "Verify contextIsolation, nodeIntegration, preload exposure, and add/adjust CSP. Validate IPC sender origins; sanitize inputs.",
        "details": "Audit BrowserWindow creation, preload API surface, and enable strict CSP for renderer assets.",
        "testStrategy": "Manual audit checklist + unit tests for preload API shape; verify no node APIs in renderer.",
        "status": "done",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Enforce security flags and narrow preload",
            "description": "Audit BrowserWindow flags; minimize preload API surface; add schema validation.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 8
          },
          {
            "id": 2,
            "title": "Add/adjust CSP",
            "description": "Add CSP meta or headers in dev/prod; restrict remote content and eval.",
            "details": "<info added on 2025-08-26T19:12:09.204Z>\nImplemented CSP hardening and consolidation: Removed meta CSP from renderer HTML (header-only now). Added environment-specific CSP in main process (dev vs prod). `script-src` updated to drop 'unsafe-inline' (allowing 'unsafe-eval' only in dev). `style-src` allows 'unsafe-inline' for CSS injection. `connect-src` allows ws/http localhost in dev and restricts to Google API in prod. Added `frame-ancestors 'none'` and `worker-src 'self' blob:`. Validated BrowserWindow flags remain secure (contextIsolation on, nodeIntegration off).\n</info added on 2025-08-26T19:12:09.204Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 8
          }
        ]
      },
      {
        "id": 9,
        "title": "Tests and CI adjustments",
        "description": "Update unit/integration tests for Gemini workflows; ensure CI scripts keep lint, type-check, packaging, and tests green.",
        "details": "Add mocks for @google/genai; update jest setup if needed; ensure streaming tests are deterministic.",
        "testStrategy": "Jest unit tests for wrappers; integration tests for streaming buffer and JSON parsing.",
        "status": "done",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add @google/genai mocks for Jest",
            "description": "Create stable mocks for SDK streaming and JSON responses.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 2,
            "title": "Unit tests for main helpers",
            "description": "Test stream and JSON helpers (happy/error/abort).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 3,
            "title": "Integration tests for renderer streaming",
            "description": "Simulate chunked updates and verify buffering/finalization.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9
          }
        ]
      },
      {
        "id": 10,
        "title": "Docs & release notes",
        "description": "Update README, AGENTS.md, and in-app copy to reference Gemini; add migration notes and release highlights.",
        "details": "Document settings changes, model defaults, and limitations; include references to Google docs.",
        "testStrategy": "Docs review checklist; ensure commands and paths resolve.",
        "status": "done",
        "dependencies": [
          "7",
          "8",
          "9"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Supabase Project Setup & Database Schema Implementation",
        "description": "Initialize the Supabase project, configure the database, and implement all core tables as defined in the PRD.",
        "details": "Create the Supabase project. Implement `users`, `user_profiles`, `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments` tables. Ensure `id`, `created_at`, `updated_at` columns are present where applicable. Add initial indexes for common query patterns (e.g., `user_id` on `piles`, `pile_id` on `posts`).",
        "testStrategy": "Verify all tables are created with correct schemas and column types. Insert sample data and confirm data integrity. Check that initial indexes are applied.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Supabase Project",
            "description": "Create a new Supabase project instance and obtain necessary API keys and configuration details.",
            "dependencies": [],
            "details": "Log in to the Supabase dashboard, create a new project, and note down the project URL and `anon` public key. This establishes the foundational environment for the database and other services.",
            "status": "pending",
            "testStrategy": "Verify the project is accessible via the Supabase dashboard and API keys are available in the project settings."
          },
          {
            "id": 2,
            "title": "Implement Core Tables with Base Columns",
            "description": "Create the initial set of core database tables as defined, ensuring `id`, `created_at`, and `updated_at` columns are present where applicable.",
            "dependencies": [
              "11.1"
            ],
            "details": "Create `users`, `user_profiles`, `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments` tables. For each, include an `id` column (UUID primary key), `created_at` (timestamp with default now()), and `updated_at` (timestamp with update trigger) columns where appropriate.",
            "status": "pending",
            "testStrategy": "Verify all specified tables exist in the Supabase database schema with the correct base columns and data types. Insert a sample row into each table to confirm column functionality."
          },
          {
            "id": 3,
            "title": "Define Table Relationships and Foreign Keys",
            "description": "Establish the relationships between the core tables by adding foreign key constraints to ensure data integrity and referential consistency.",
            "dependencies": [
              "11.2"
            ],
            "details": "Add foreign key constraints, for example: `user_profiles.user_id` to `users.id`, `piles.user_id` to `users.id`, `pile_members.user_id` to `users.id` and `pile_members.pile_id` to `piles.id`, `posts.user_id` to `users.id` and `posts.pile_id` to `piles.id`, `post_replies.user_id` to `users.id` and `post_replies.post_id` to `posts.id`, `post_tags.post_id` to `posts.id`, `post_highlights.post_id` to `posts.id`, and `attachments.post_id` to `posts.id`.",
            "status": "pending",
            "testStrategy": "Attempt to insert data that violates foreign key constraints (e.g., a post with a non-existent user_id) to confirm they are correctly enforced. Verify relationships are visible and correct in the Supabase schema visualizer."
          },
          {
            "id": 4,
            "title": "Implement Database Row Level Security (RLS) Policies",
            "description": "Configure Row Level Security policies for all core tables to control data access based on user roles and ownership, ensuring data privacy and security.",
            "dependencies": [
              "11.3"
            ],
            "details": "Enable RLS for `users`, `user_profiles`, `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments`. Define policies that allow users to read/write their own data, and access data within piles they are members of, as appropriate for each table's context.",
            "status": "pending",
            "testStrategy": "Test data access from different authenticated users (e.g., user A trying to read user B's private profile or a post in a pile they are not a member of) and unauthenticated users to ensure RLS policies are correctly applied and prevent unauthorized access."
          },
          {
            "id": 5,
            "title": "Add Initial Database Indexes",
            "description": "Create initial indexes on frequently queried columns to optimize database performance for common access patterns.",
            "dependencies": [
              "11.3"
            ],
            "details": "Add indexes for common query patterns as specified: `user_id` on `piles` and `pile_id` on `posts`. Additionally, consider adding indexes on other foreign key columns like `user_id` on `user_profiles`, `post_id` on `post_replies`, etc., to improve join performance.",
            "status": "pending",
            "testStrategy": "Verify that the specified indexes are present in the database schema. Run simple queries that utilize these indexed columns and, if possible, analyze query plans to confirm index usage and performance improvement."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Supabase Authentication (Email/Password & Google OAuth)",
        "description": "Integrate Supabase Auth for user sign-up, sign-in, and session management using email/password and Google OAuth.",
        "details": "Configure Supabase Auth in the project. Enable Email/Password and Google OAuth providers. Implement client-side logic using `supabase-js` for user registration, login, logout, and session persistence. Securely store authentication tokens within the Electron application.",
        "testStrategy": "Test user registration, login, and logout with both email/password and Google accounts. Verify session persistence across app restarts. Confirm secure token storage.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Project & Client",
            "description": "Set up the Supabase project, enable Email/Password and Google OAuth providers in the Supabase dashboard, and initialize the `supabase-js` client in the Electron application.",
            "dependencies": [],
            "details": "Obtain Supabase URL and Anon Key. Configure these in the Electron app's environment or configuration files. Enable Email/Password and Google OAuth in the Supabase Auth settings within the Supabase dashboard.",
            "status": "pending",
            "testStrategy": "Verify Supabase client initializes without errors in the Electron app's console. Confirm Email/Password and Google OAuth providers are visibly enabled in the Supabase dashboard's authentication settings."
          },
          {
            "id": 2,
            "title": "Implement Email/Password Sign-up, Sign-in, and Logout",
            "description": "Develop the client-side logic using `supabase-js` for user registration, login, and logout specifically for email/password authentication.",
            "dependencies": [
              "12.1"
            ],
            "details": "Implement functions for `supabase.auth.signUp({ email, password })`, `supabase.auth.signInWithPassword({ email, password })`, and `supabase.auth.signOut()`. Design and integrate basic UI components (forms, buttons) for these authentication actions within the Electron application.",
            "status": "pending",
            "testStrategy": "Test user registration with a new email and password. Verify successful login and logout. Attempt login with incorrect credentials (wrong email, wrong password) and verify error handling. Confirm user data appears in Supabase Auth users table."
          },
          {
            "id": 3,
            "title": "Integrate Google OAuth Sign-in",
            "description": "Implement the client-side logic to allow users to sign in using their Google accounts via Supabase OAuth.",
            "dependencies": [
              "12.1"
            ],
            "details": "Implement `supabase.auth.signInWithOAuth({ provider: 'google' })`. Handle the OAuth redirect flow appropriate for an Electron application, which may involve using a custom protocol handler or an in-app browser window for the authentication process and capturing the callback.",
            "status": "pending",
            "testStrategy": "Test sign-in with a valid Google account. Verify successful authentication and the creation of a user session. Confirm the user's Google profile information is correctly retrieved and associated with the Supabase user."
          },
          {
            "id": 4,
            "title": "Implement Session Management and Persistence",
            "description": "Develop the logic to manage user sessions, including refreshing tokens and ensuring session persistence across application restarts.",
            "dependencies": [
              "12.2",
              "12.3"
            ],
            "details": "Utilize `supabase-js`'s built-in session management capabilities. Implement mechanisms to listen for authentication state changes (`supabase.auth.onAuthStateChange`). Ensure the user's session is re-established automatically when the Electron application restarts, relying on `supabase-js`'s internal storage or a custom secure storage solution.",
            "status": "pending",
            "testStrategy": "Log in using both Email/Password and Google OAuth. Close and reopen the Electron application and verify the user remains logged in without needing to re-authenticate. Test session refresh after a period of inactivity or token expiration."
          },
          {
            "id": 5,
            "title": "Securely Store Authentication Tokens",
            "description": "Implement a secure method for storing authentication tokens within the Electron application to prevent unauthorized access.",
            "dependencies": [
              "12.4"
            ],
            "details": "Research and implement a secure storage solution for Electron, such as `electron-store` with encryption, `keytar` (for OS-level keychain/credential manager integration), or a custom encrypted file storage mechanism. Ensure that access tokens, refresh tokens, and other sensitive session data are not stored in plain text.",
            "status": "pending",
            "testStrategy": "Verify that authentication tokens are stored securely (e.g., not readable in plain text from the file system or developer tools). Test that tokens can be retrieved correctly for session persistence. Attempt to manually tamper with stored tokens and verify the application handles it gracefully (e.g., forces re-login or invalidates the session)."
          }
        ]
      },
      {
        "id": 13,
        "title": "Develop Core Sync Infrastructure & Offline Queue",
        "description": "Establish the foundational client-side sync mechanism and an offline queue for pending operations to support offline-first functionality.",
        "details": "Design and implement a local data cache (e.g., SQLite or IndexedDB) to mirror Supabase data. Create an 'offline queue' to store all CUD (Create, Update, Delete) operations when the application is offline. Implement a mechanism to detect network connectivity changes and automatically replay queued operations to Supabase upon reconnection.",
        "testStrategy": "Simulate offline mode: create/edit/delete entries, then go online and verify successful sync. Test with multiple operations queued. Ensure data consistency after sync.",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Local Data Cache",
            "description": "Design and implement the client-side local data cache to mirror Supabase data, providing basic CRUD operations for local storage.",
            "dependencies": [],
            "details": "Choose a local storage solution (e.g., SQLite for Electron/mobile, IndexedDB for web). Define the schema for `posts` and `piles` tables locally, mirroring their Supabase structure. Implement methods for creating, reading, updating, and deleting records within this local cache.",
            "status": "pending",
            "testStrategy": "Verify local CRUD operations function correctly. Ensure data persistence across application restarts and that the local cache accurately reflects the intended schema."
          },
          {
            "id": 2,
            "title": "Develop Offline Operations Queue",
            "description": "Create a mechanism to capture and store all CUD (Create, Update, Delete) operations when the application is offline, preparing them for later synchronization.",
            "dependencies": [
              "13.1"
            ],
            "details": "Design a dedicated structure (e.g., a table within the local data cache) to store pending CUD operations. Each queued item should include the operation type (Create, Update, Delete), target table, relevant data/payload, a unique identifier, and a timestamp. Implement an interception layer for application CUD calls to push operations to this queue when offline.",
            "status": "pending",
            "testStrategy": "Simulate offline mode. Perform various CUD operations (create, edit, delete) and verify they are correctly stored in the offline queue. Check queue content for accuracy and completeness of operation details."
          },
          {
            "id": 3,
            "title": "Implement Network Connectivity Detection",
            "description": "Develop a robust mechanism to detect changes in network connectivity status (online/offline) to trigger appropriate sync behaviors.",
            "dependencies": [],
            "details": "Implement listeners for browser `online`/`offline` events or use a more sophisticated method (e.g., periodic pings to a known endpoint) to determine actual connectivity. Provide a clear API or event system to notify other parts of the application about connectivity status changes.",
            "status": "pending",
            "testStrategy": "Toggle network connectivity (Wi-Fi, airplane mode, disconnect/reconnect Ethernet) and verify the application accurately detects and reports online/offline status changes in real-time."
          },
          {
            "id": 4,
            "title": "Develop Queued Operations Replay Logic",
            "description": "Implement the core logic to automatically replay all stored offline CUD operations to Supabase upon network reconnection.",
            "dependencies": [
              "13.1",
              "13.2",
              "13.3"
            ],
            "details": "Upon detecting an 'online' state, iterate through the offline queue. For each queued operation, execute the corresponding CUD operation against Supabase. Handle successful operations by removing them from the queue. Implement basic error handling for failed operations during replay (e.g., retry mechanism, marking as failed). Ensure operations are replayed in a logical order (e.g., creation before updates/deletions on the same entity).",
            "status": "pending",
            "testStrategy": "Simulate offline mode, perform multiple CUD operations (create, update, delete across different entities). Go online and verify all queued operations are successfully replayed to Supabase and removed from the queue. Check Supabase for data consistency and accuracy."
          },
          {
            "id": 5,
            "title": "Implement Initial Conflict Resolution Strategy",
            "description": "Establish a basic conflict resolution strategy for replayed operations to ensure data consistency during sync, specifically 'last-write-wins'.",
            "dependencies": [
              "13.4"
            ],
            "details": "Implement a 'last-write-wins' strategy for conflicts that may arise when replaying queued operations. This involves ensuring that the most recent change (based on a `last_modified_at` timestamp or version) takes precedence. For the initial implementation, this means the replayed local change will overwrite the server's state if a conflict occurs on the same record during replay.",
            "status": "pending",
            "testStrategy": "Simulate a conflict scenario: go offline, modify a record. While offline, modify the *same* record directly in Supabase (e.g., via another client or direct DB access). Go online and verify the 'last-write-wins' strategy correctly resolves the conflict, with the expected change (local or remote, based on timestamp) persisting."
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement Row Level Security (RLS) Policies",
        "description": "Define and apply Row Level Security policies to all relevant tables to ensure user data isolation and secure access.",
        "details": "Enable RLS on `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments` tables. Write policies to ensure users can only access their own data or data from piles they are explicitly members of. Test policies rigorously to prevent unauthorized data access.",
        "testStrategy": "Attempt to access data belonging to other users or unshared piles from a logged-in user. Verify that RLS correctly denies access. Test various user roles and permissions.",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enable RLS on all specified tables",
            "description": "Activate Row Level Security for `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments` tables in the database.",
            "dependencies": [],
            "details": "Execute `ALTER TABLE <table_name> ENABLE ROW LEVEL SECURITY;` for each of the seven specified tables: `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments`.",
            "status": "pending",
            "testStrategy": "Verify that RLS is enabled for each table by querying `pg_policies` or `information_schema.tables` in the database."
          },
          {
            "id": 2,
            "title": "Implement RLS policies for direct user ownership",
            "description": "Create RLS policies that allow users to access rows where they are the direct owner (e.g., `user_id = auth.uid()`).",
            "dependencies": [
              "14.1"
            ],
            "details": "Create `CREATE POLICY` statements for `SELECT`, `INSERT`, `UPDATE`, `DELETE` operations on tables where data is directly owned by a user (e.g., `posts`, `attachments`, `piles` if a user owns a pile directly) using `auth.uid() = user_id` or similar conditions.",
            "status": "pending",
            "testStrategy": "As user A, create data. Log in as user B and attempt to read/update/delete user A's data. Verify access is denied. Log in as user A and verify full access to own data."
          },
          {
            "id": 3,
            "title": "Implement RLS policies for pile membership",
            "description": "Develop RLS policies that grant access to data associated with piles where the current user is an explicit member.",
            "dependencies": [
              "14.1"
            ],
            "details": "Develop `CREATE POLICY` statements for `SELECT`, `INSERT`, `UPDATE`, `DELETE` operations on tables associated with piles (e.g., `posts`, `post_replies`, `post_tags`, `post_highlights`, `attachments`, `pile_members`) that check if `auth.uid()` is a member of the relevant `pile_id` using subqueries or `EXISTS` clauses against the `pile_members` table.",
            "status": "pending",
            "testStrategy": "Create a pile and add user A and user B as members. User A creates a post in that pile. Log in as user B and verify access to user A's post within the shared pile. Log in as user C (not a member) and verify access is denied."
          },
          {
            "id": 4,
            "title": "Consolidate and apply all RLS policies to target tables",
            "description": "Combine and apply all defined RLS policies (user ownership and pile membership) to ensure comprehensive and correct access control across all specified tables.",
            "dependencies": [
              "14.2",
              "14.3"
            ],
            "details": "Review and combine the user ownership and pile membership policies. For tables requiring both access types, merge conditions using `OR`. Apply these final, comprehensive policies to all seven specified tables: `piles`, `pile_members`, `posts`, `post_replies`, `post_tags`, `post_highlights`, and `attachments`.",
            "status": "pending",
            "testStrategy": "Perform a final review of all `CREATE POLICY` statements for syntax, logical correctness, and complete coverage across all specified tables and operations."
          },
          {
            "id": 5,
            "title": "Conduct comprehensive RLS policy testing and validation",
            "description": "Execute a thorough testing strategy to verify that all RLS policies correctly enforce data isolation and secure access, covering various user roles and access scenarios.",
            "dependencies": [
              "14.4"
            ],
            "details": "Execute the parent task's test strategy: 'Attempt to access data belonging to other users or unshared piles from a logged-in user. Verify that RLS correctly denies access. Test various user roles and permissions.' This involves developing and running a suite of test cases for `SELECT`, `INSERT`, `UPDATE`, `DELETE` operations across all tables under different user contexts (owner, pile member, non-member).",
            "status": "pending",
            "testStrategy": "Develop and execute a comprehensive test plan including: 1. Verifying successful access for owners and pile members. 2. Confirming denial of access for unauthorized users (other users' private data, unshared piles). 3. Testing edge cases, such as data without a direct `user_id` or `pile_id` if applicable, and different user roles."
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement Post & Pile Data Synchronization",
        "description": "Develop the core logic for synchronizing `posts` and `piles` data between the local cache and Supabase, including initial fetch and incremental updates.",
        "details": "Implement CRUD operations for `posts` and `piles` that interact with both the local cache and Supabase. Handle the initial data fetch from Supabase to populate the local cache. Implement incremental updates for new, modified, or deleted entries. Initially, use a 'last-write-wins' strategy for conflict resolution.",
        "testStrategy": "Create, update, and delete posts/piles on one device and verify immediate sync to another. Test with large number of entries. Verify data consistency across devices after sync.",
        "priority": "high",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Initial Supabase Data Fetch & Local Cache Population",
            "description": "Develop the logic to perform a one-time, comprehensive fetch of all user-accessible `posts` and `piles` from Supabase. This data will then be used to fully populate and initialize the local cache, establishing the baseline for synchronization.",
            "dependencies": [],
            "details": "Query Supabase for all `posts` and `piles` relevant to the current user, respecting RLS policies. Store the fetched data efficiently in the local cache, ensuring the cache accurately reflects the remote state at the time of initialization.",
            "status": "pending",
            "testStrategy": "Verify that after initial fetch, the local cache contains all expected data from Supabase for the logged-in user. Test with empty and populated Supabase databases."
          },
          {
            "id": 2,
            "title": "Develop Local Cache CRUD Operations for Posts & Piles",
            "description": "Create the core Create, Read, Update, and Delete (CRUD) functionalities for `posts` and `piles` within the local cache. These operations will serve as the primary interface for the application to interact with cached data, independent of Supabase.",
            "dependencies": [],
            "details": "Implement functions such as `createPostLocal(postData)`, `getPostLocal(id)`, `updatePostLocal(id, newData)`, `deletePostLocal(id)` for both `posts` and `piles`. Ensure these operations maintain the integrity and structure of the local cache.",
            "status": "pending",
            "testStrategy": "Perform various CRUD operations directly on the local cache and verify that data is correctly stored, retrieved, modified, and deleted without external dependencies."
          },
          {
            "id": 3,
            "title": "Implement Local-to-Supabase Write-Through & Basic Conflict Handling",
            "description": "Develop the mechanism to automatically push local `posts` and `piles` CRUD operations to Supabase. This subtask includes implementing the initial 'last-write-wins' strategy for local changes being written to Supabase, ensuring local modifications are persisted remotely.",
            "dependencies": [
              "15.2"
            ],
            "details": "When a `create`, `update`, or `delete` operation occurs in the local cache (via 15.2), trigger a corresponding operation on Supabase. For updates, if a conflict is detected (e.g., remote version is older), the local change will overwrite the remote (last-write-wins from local perspective).",
            "status": "pending",
            "testStrategy": "Create, update, and delete posts/piles locally and verify that these changes are immediately reflected in Supabase. Simulate a conflict where a local change overwrites a remote change."
          },
          {
            "id": 4,
            "title": "Implement Supabase-to-Local Cache Incremental Sync (Pull Mechanism)",
            "description": "Develop the logic to periodically or reactively pull incremental updates (new, modified, or deleted `posts` and `piles`) from Supabase and stage them for application to the local cache. This ensures the local cache stays aware of changes originating from other clients or direct Supabase interactions.",
            "dependencies": [
              "15.1",
              "15.2",
              "15.3"
            ],
            "details": "Implement a mechanism (e.g., a background process, a listener for Supabase Realtime events, or a polling strategy) to detect and fetch changes in `posts` and `piles` tables on Supabase. Store these incoming changes temporarily before applying them to the local cache.",
            "status": "pending",
            "testStrategy": "Make changes directly in Supabase (or from another client) and verify that the local client detects and fetches these changes. Test with new, updated, and deleted entries."
          },
          {
            "id": 5,
            "title": "Implement Last-Write-Wins Conflict Resolution & Local Cache Reconciliation",
            "description": "Implement the core 'last-write-wins' conflict resolution strategy for merging the incremental updates pulled from Supabase (from 15.4) into the local cache. This ensures that the local cache is consistently updated, with remote changes taking precedence in case of conflicts.",
            "dependencies": [
              "15.4"
            ],
            "details": "Process the staged incoming changes from Supabase. For each change, compare it with the current local cache state. If a conflict is detected (e.g., the same item was modified both locally and remotely), the remote version (the 'last write') will overwrite the local version. Reconcile the local cache to reflect these merged changes.",
            "status": "pending",
            "testStrategy": "Simulate simultaneous edits on the same post/pile from different devices. Verify that the remote change correctly overwrites the local change, and the local cache reflects the 'last-write-wins' outcome. Test with various conflict scenarios (create/create, update/update, delete/update)."
          }
        ]
      },
      {
        "id": 16,
        "title": "Develop 'Enable Cloud Sync' UI & Migration Wizard",
        "description": "Create the user interface for enabling cloud sync and a guided migration wizard for existing local data.",
        "details": "Design and implement a 'Cloud Sync' section in the application settings. Include an 'Enable Supabase Sync' toggle. Develop a multi-step migration wizard for existing users to upload their local piles to Supabase, including pile selection, estimated size, a progress bar, and a verification step comparing local vs. cloud data.",
        "testStrategy": "Test the entire migration flow with various local data sizes. Verify progress bar accuracy and data integrity post-migration. Ensure rollback capabilities function correctly if issues arise.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Conflict Resolution Strategy",
        "description": "Refine the conflict resolution mechanism for simultaneous edits or offline changes, providing user-friendly options.",
        "details": "Enhance the 'last-write-wins' strategy with more sophisticated conflict detection. Design and implement a UI/UX for users to be notified of conflicts and potentially choose between conflicting versions or merge changes, especially for collaborative editing scenarios.",
        "testStrategy": "Simulate simultaneous edits on the same post from different devices. Test offline edits followed by online edits. Verify the conflict resolution UI is clear and functional.",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Real-time Post Editing & Presence",
        "description": "Integrate Supabase Realtime for live synchronization of post content, live cursor positions, and user presence within shared piles.",
        "details": "Utilize `supabase.channel` to subscribe to `posts` changes within a specific pile for real-time content updates. Implement a mechanism for live cursor positions (e.g., using a dedicated presence channel or a temporary table). Develop UI to display presence indicators (who is currently online and viewing/editing a pile).",
        "testStrategy": "Test real-time editing from multiple clients simultaneously. Verify cursor positions update accurately. Confirm presence indicators reflect active users in a pile.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Develop Pile Sharing & Member Management UI",
        "description": "Create the user interface and backend logic for sharing piles with other users and managing collaborators' permissions.",
        "details": "Implement functionality to generate shareable links for piles, allowing users to invite others. Develop a UI for managing pile members, including inviting, removing, and assigning roles/permissions (e.g., read-only, editor) using the `pile_members` table. Ensure RLS policies are respected.",
        "testStrategy": "Test sharing a pile with different permission levels. Verify invited users can access/edit based on their role. Confirm the owner can remove members and revoke access.",
        "priority": "high",
        "dependencies": [
          14,
          18
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Integrate Supabase Storage for Attachments",
        "description": "Implement secure file upload, download, and management for attachments using Supabase Storage buckets.",
        "details": "Create `pile-attachments` and `user-avatars` storage buckets in Supabase. Implement client-side logic for securely uploading images and other files, associating them with `posts` via the `attachments` table. Develop functionality to download and display these attachments. Configure RLS for storage buckets to ensure only authorized users can access files.",
        "testStrategy": "Upload various file types and sizes. Verify successful upload, secure storage, and correct display/download. Test RLS by attempting to access unauthorized files.",
        "priority": "high",
        "dependencies": [
          11,
          14,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Full-Text Search on Post Content",
        "description": "Add efficient full-text search capabilities across all user's journal entries using PostgreSQL's built-in features.",
        "details": "Configure a `tsvector` column on the `posts` table, automatically updating it on content changes using a trigger. Implement a search API endpoint that utilizes `to_tsquery` for fast and relevant full-text search across all posts accessible to the user. Optimize search queries for performance.",
        "testStrategy": "Perform searches with various keywords, phrases, and special characters. Verify search results are accurate and returned within the performance requirements (<1 second). Test search across large datasets.",
        "priority": "medium",
        "dependencies": [
          11,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Develop Sync Status Indicators & Error Handling UI",
        "description": "Create clear visual indicators for sync status, connection status, and user-friendly error messages for sync-related issues.",
        "details": "Implement UI elements (e.g., sidebar icons, status bar indicators) to visually communicate 'synced', 'syncing', 'offline', and 'conflict' states. Design and implement clear, actionable error messages and recovery options for network issues, sync failures, or data conflicts.",
        "testStrategy": "Simulate various network conditions (offline, slow, intermittent). Verify UI indicators accurately reflect status. Trigger sync errors and confirm user-friendly error messages are displayed with guidance.",
        "priority": "medium",
        "dependencies": [
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Data Export Functionality",
        "description": "Allow users to export their complete journal data from Supabase in a common, accessible format.",
        "details": "Develop a feature that enables users to export their entire journal data (posts, attachments metadata, pile structure) in a user-friendly format such as JSON or a collection of Markdown files. Consider using Supabase Functions to generate the export file server-side and store it temporarily in an `exports` storage bucket for download.",
        "testStrategy": "Export data for users with varying amounts of content and attachments. Verify the exported data is complete, correctly formatted, and easily importable/readable. Test the download process.",
        "priority": "low",
        "dependencies": [
          15,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Performance Optimization & Load Testing",
        "description": "Conduct comprehensive performance testing, identify bottlenecks, and optimize database queries, real-time subscriptions, and sync logic.",
        "details": "Perform load testing for concurrent users and large datasets to identify performance bottlenecks. Optimize SQL queries by adding necessary composite indexes and refining existing ones. Fine-tune real-time subscriptions and client-side sync logic to meet performance requirements (e.g., <2s sync latency, <500ms query response, <100ms real-time latency).",
        "testStrategy": "Use profiling tools to identify slow queries. Conduct stress tests with simulated users. Monitor Supabase metrics for database performance. Verify all performance requirements are met under load.",
        "priority": "high",
        "dependencies": [
          15,
          18,
          20,
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Comprehensive End-to-End Testing & Documentation",
        "description": "Conduct final end-to-end testing, user acceptance testing (UAT), and create user documentation for all new cloud features.",
        "details": "Develop and execute comprehensive end-to-end test plans covering all user stories, technical requirements, and edge cases. Organize beta testing with a group of users to gather feedback. Create clear and concise user documentation, including guides for cloud sync, collaboration, data migration, and troubleshooting common issues.",
        "testStrategy": "Execute full regression test suite. Conduct UAT sessions and collect feedback. Review all documentation for accuracy, clarity, and completeness. Verify all success criteria from the PRD are met.",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-26T16:05:18.194Z",
      "updated": "2025-08-27T08:41:53.121Z",
      "description": "Tasks for research context"
    }
  }
}